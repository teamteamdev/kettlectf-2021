# Quadratic asm?: Write-up

Читаем и понимаем, что нас просят решить квадратное уравнение. Вроде бы задача
простая, но мелким текстом сказано, что писать нам придется на чем-то необычном.
Переходим по ссылке и видим описание языка программирования и машины. Есть
макросы, сложение, вычитание, пара условных переходов и стек. А также 4
регистра.

Сначала будет полезно написать решение на чем-нибудь попроще, например, на Python:
[solution.py](writeup/solution.py).
```python
import math

a = int(input())
b = int(input())
c = int(input())

if a == b == 0:
    print('none' if c else 'inf')
elif a == 0:
    x = -c // b
    print(x)
else:
    d = b**2 - 4 * a * c
    if d < 0:
        print('none')
    elif math.isclose(d, 0):
        x = -b // (2 * a)
        print(x)
    else:
        d = round(math.sqrt(d))
        x1 = (-b - d) // (2 * a)
        x2 = (-b + d) // (2 * a)
        print(x1, x2)
```

Тут мы уже вспоминаем про все возможные потайные камни, вроде a = 0, отсуствия и
бесконечного количества решений. И примерно накидываем алгоритм, который нам нужно реализовать.

Заметим несколько простых идей:
1. `je 0 "label"` --- безусловный переход. Пригодится
2. У нас мало регистров, но бесконечный стек. Будем активно им пользоваться.
3. Нам сказали, что Вася не знает дробей, поэтому можем быть уверены, что все
   числа будут хорошо делиться, а корни извлекаться.

Читаем наше решение и видим три операции, которые нам не дали изначально: умножение, деление и взятие квадратного корня. Реализуем их через макросы, а аргументы будем передавать через стек.
2. Изобретем стековую машину

Их реализация может показаться простой: делаем цикл со сложением\вычитанием. Но
тут главное не забыть про отрицательные аргументы. Сохраним в регистре c ноль, а
потом будет увеличивать его на единицу, если первый аргумент отрицательный и
уменьшать на единицу, если второй отрицательный. В конце, если c != 0, то нам
надо инвертировать результат.

Для примера приведем код макроса умножения.
```
#define mul
pop a
pop b
sub c c

jl a "{}aNeg"
je 0 "{}aPos"

aNeg:
add c 1
push a
neg!
pop a

aPos:
jl b "{}bNeg"
je 0 "{}bPos"

bNeg:
sub c 1
push a
push b
neg!
pop b
pop a

bPos:
sub d d

loop:
je b "{}end"
sub b 1
add d a
je 0 "{}loop"

end:
push d
je c "{}return"
neg!

return:
#enddefine
```

Тут `neg!` --- вспомогательный макрос, который инвертирует значение на стеке.

Надо не забывать проверять перед выходом, что на стеке нет лишних значений.

Полный код решения [solution](writeup/solution).

> Нам заботливо дали виртуальную машину, чтобы мы могли запускать тесты у себя
> (или найти уязвимость и сломать сервис). Одной из простых идей является метка
> end последней строкой и печать je 0 "end" в том месте, где мы хотим узнать
> состояние стека (можно перед этим туда положить интересующие нас регистры).

Загружаем его в проверочную систему, получаем флаг и хвастаемся результатами по циклам в чате.

Флаг: **kettle\_va39a\_wi1l\_buy\_c0okies\_for_u**
