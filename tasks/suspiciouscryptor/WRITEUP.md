# Подозрительный шифровальщик: Write-up
Нам даны 3 файла: bash-скрипт, зашифрованное сообщение и бинарный файл.

Взглянем на bash-скрипт:
```sh
./enc message.txt $(((RANDOM % 10000) + 1))
```
Видим, что скрипт запускает исполняемый файл `enc` и передаёт 2 параметра: путь к файлу с сообщением и случайное число (от 1 до 10000).

Теперь зареверсим бинарный файл.

1) Изучаем функцию `main`:<br>![main](src/imgs/main.jpg)
   1) Нас будут интересовать строки 21 - 32.
   2) Изучив код, понимаем, что здесь открывается и читается сообщение в буфер (его длина, как и длина ключа - 64), затем в этот же файл происходит запись зашифрованного текста (кстати посимвольно).
   3) До того, как начать шифровать, генерируется ключ с помощью сида, который мы передали вторым параметром.
2) Теперь рассмотрим функцию `generate_key`:<br>![generate_key](src/imgs/generate_key.jpg)
   1) Замечаем, что сид генерируется по формуле: <br>
   `seed = (seed * 0x80 + 0x539) % 0x7f`, то есть <br>
   `seed = (seed * 128 + 1337) % 127`
   1) Следовательно мы сможем восстановить ключ, перебрав сиды.
3) Взглянем на функцию с интересным названием `last_function`:<br>![last_function](src/imgs/last_function.jpg)
   1) Видим вызов функций с не менее интересными названиями (скорее всего это было сделано, чтобы запутать нас). Тогда рассмотрим и эти функции тоже.
   2) Обе функции ссылаются на ещё одну под названием `some_function` <br> ![curious_function](src/imgs/curious_function.jpg) <br> ![another_curious_function](src/imgs/another_curious_function.jpg)
   3) А вот уже эта функция до безобразия проста. <br> ![some_function](src/imgs/some_function.jpg)<br> Это `NAND`. Интересно, что с помощью этой логической функции можно представить любую другую логическую функцию ([а вот и ссылочка](https://en.wikipedia.org/wiki/Sheffer_stroke)).
   4) Действительно, изучив функции, можно обнаружить, что `curious_function` - это импликация, <br> `another_curious_function` - исключающее или.
   5) Вернёмся к `last_function`. <br> Разобравшись с остальными функциями, мы можем узнать, что же делает эта. <br> Получаем логическое выражение: <br> `a⊕((a⇒b)∧((a∧b)⊕(a⊕b)))`. Оно эквивалентно `a⊕b` (можно было использовать онлайн тулзу для упрощения, например [эту](https://www.kontrolnaya-rabota.ru/s/mathlogic/?expr=a%E2%8A%95%28%28a%E2%87%92b%29%E2%88%A7%28%28a%E2%88%A7b%29%E2%8A%95%28a%E2%8A%95b%29%29%29))
4) Делаем вывод о том, что исполняемы файл `enc` просто ксорит исходное сообщение со случайно сгенерированным ключом.
5) Напишем программу, которая переберёт все сиды, сгенерирует ключ и получит флаг с помощью `xor`:
```python
def generate_key(seed):
    key = []
    for _ in range(64):
        seed = (seed * 128 + 1337) % 127
        # не самая лучшая формула для генерации ключа
        # так как для многих сидов сгенерируется один и тот же ключ
        # не делайте так :^) 
        key.append(seed)
    return key


with open("message.txt", "rb") as f:
    message = f.read()

for seed in range(1, 10001):
    key = generate_key(seed)
    # Мы знаем, что флаг начинается с kettle_
    # Поэтому будем проверять только первые 7 байт
    # Если всё совпадёт, то это флаг
    flag_start = "kettle_"
    dec = ""
    for i in range(64):
        dec += chr(message[i] ^ key[i])
        if i <= 6 and dec[i] != flag_start[i]:
            break
    else:
        print(dec)
        break
```

Флаг: **kettle_nand_expression_conversions_bitwise_operators_xor_reverse**
