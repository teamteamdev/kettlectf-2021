# Ошибка сервера: Write-up

На приложенной картинке мы видим компьютер и сервер. Если прочитать описание таска, в котором клиент и сервер создают общий приватный ключ, а на картинке обратить внимание на подписанные буквы p и g, можно предположить что изображен протокол Диффи-Хеллмана. Гуглим этот протокол и смотрим какие формулы в нем используются. 
На вики написано, что p и g – это первоначальные числа. Они используются для дальнейшего создания публичных ключей, а также приватного.  Ищем формулы нахождения ключей.
Формула для нахождения приватного ключа: A^b mod p, где mod p – это остаток от деления на p.
A – это публичный ключ, который отравляет клиент.
b – это то самое секретное число, которое по ошибке отправил сервер.
Число p нам уже известно.
Напишем небольшой код на python

```python 
p = 302304118860350364158943550303980866023
b = 236003563297020237938193631849667525989
A = 54566218418101445259704889938799898519
private_key = pow(A,b,p)
print(private_key) 
```

Выполняем этот код и получаем KEY.
Смотрим файл, который у нас есть. В нем написано AES  CREATED_BY pyAesCrypt 6.0.0. Ищем pyAesCrypt в любом поисковике и находим информацию о нем. Это библиотека для python. Этой библиотекой можно шифровать файлы по протоколу AES.
У нас имеется зашифрованный файл .aes и информация, что он зашифрован строкой.
Пишем код на питоне, который расшифрует файл

```python
key = input('Enter key: ') 
bufferSize = 512*1024
pyAesCrypt.decryptFile("flag.txt.aes","kettle_flag.txt",key,bufferSize)
```

Этот код расшифрует файл нашим ключем.
Открываем файл и находим флаг.

Флаг: **kettle_diffie_hellman_and_aes_easy_e5ffgs78g9l0f**
